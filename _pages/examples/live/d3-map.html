---
permalink: /examples/live/d3-map/
---

<html>

<head>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="{{ '/assets/citysdk.js' | relative_url }}"></script>
    <script src="https://d3js.org/topojson.v2.min.js"></script>
    <style>
        html,
        body {
            margin: 0;
        }

        path {
            stroke: rgb(158, 158, 158);
            stroke-width: 0.2;
        }

        path:hover {
            fill: #a33f32;
            cursor: pointer;
        }

        div.tooltip {
            position: absolute;
            text-align: center;
            max-width: 10em;
            padding: 0.5em;
            font: 1em sans-serif;
            background: rgb(53, 53, 53);
            color: white;
            border: 0px;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <svg id="map" width="800" height="600"></svg>

</body>
<script>
    function censusPromise(args) {
        return new Promise((resolve, reject) => {
            census(args, (err, json) => {
                if (!err) {
                    resolve(json);
                } else {
                    reject(err);
                }
            });
        });
    }

    Promise.all(
            [
                d3.json("https://cdn.jsdelivr.net/npm/us-atlas@3/counties-10m.json"),
                censusPromise({
                    vintage: 2019,
                    geoHierarchy: {
                        county: "*"
                    },
                    sourcePath: ["acs", "acs5"],
                    values: ["B17001_001E", "B17001_002E"]
                })
            ])
        .then(d => ready(null, d[0], d[1]))

    function ready(error, us, census_data) {
        const svg = d3.select("#map"),
            margin = 10,
            width = +svg.attr("width") - margin,
            height = +svg.attr("height") - margin;

        const tooltip = d3.select("body").append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);

        // Map and projection
        const projection = d3.geoAlbersUsa().scale(width).translate([width / 2, height / 2])
        const path = d3.geoPath(projection);

        //assign data to a Map object (has a hashed get method)
        const data = Object.assign(new Map(census_data.map(({
            B17001_001E,
            B17001_002E,
            county,
            state
        }) => [`${state}${county}`, {
            value: B17001_002E / B17001_001E // calcuate percent
        }])), {
            title: "Percent of population with income in the past 12 months below poverty level"
        })

        //generate legend
        const extent = d3.extent(Array.from(data.values()).map(i => i.value));
        const colorScale = d3.scaleQuantile()
            .domain(extent)
            .range(d3.schemeBlues[7]);

        // Draw the map
        svg.append("g")
            .selectAll("path")
            .data(topojson.feature(us, us.objects.counties).features)
            .enter()
            .append("path")
            .attr("d", path)
            .attr("fill", d => {
                const entry = data.get(d.id);
                return entry ? colorScale(entry.value) : 'rgb(155,155,155)'
            })
            .on("mouseover", e => {
                tooltip.transition()
                    .duration(200)
                    .style("opacity", .9);
                tooltip.html(() => {
                        const format = d3.format('.2f')
                        return `<strong>${e.properties.name}</strong>: ${format(data.get(e.id).value * 100)}%`;
                    })
                    .style("left", (d3.event.pageX) + "px")
                    .style("top", (d3.event.pageY - 28) + "px");
                //todo add tip
            })
            .on("mouseout", () => {
                tooltip.transition()
                    .duration(500)
                    .style("opacity", 0);
            });

        // Add legend
        svg.append("g")
            .attr("transform", `translate(${width /2},${margin /2 })`)
            .append(() => legend({
                color: colorScale,
                title: data.title,
                width: 260,
                tickFormat: ".2f"
            }));
    }
</script>
<script>
    // from https://observablehq.com/@d3/color-legend
    function legend({
        color,
        title,
        tickSize = 6,
        width = 320,
        height = 44 + tickSize,
        marginTop = 18,
        marginRight = 0,
        marginBottom = 16 + tickSize,
        marginLeft = 0,
        ticks = width / 64,
        tickFormat,
        tickValues
    } = {}) {

        const svg = d3.create("svg")
            .attr("width", width)
            .attr("height", height)
            .attr("viewBox", [0, 0, width, height])
            .style("overflow", "visible")
            .style("display", "block");

        let x;

        // Continuous
        if (color.interpolator) {
            x = Object.assign(color.copy()
                .interpolator(d3.interpolateRound(marginLeft, width - marginRight)), {
                    range() {
                        return [marginLeft, width - marginRight];
                    }
                });

            svg.append("image")
                .attr("x", marginLeft)
                .attr("y", marginTop)
                .attr("width", width - marginLeft - marginRight)
                .attr("height", height - marginTop - marginBottom)
                .attr("preserveAspectRatio", "none")
                .attr("xlink:href", ramp(color.interpolator()).toDataURL());

            // scaleSequentialQuantile doesnâ€™t implement ticks or tickFormat.
            if (!x.ticks) {
                if (tickValues === undefined) {
                    const n = Math.round(ticks + 1);
                    tickValues = d3.range(n).map(i => d3.quantile(color.domain(), i / (n - 1)));
                }
                if (typeof tickFormat !== "function") {
                    tickFormat = d3.format(tickFormat === undefined ? ",f" : tickFormat);
                }
            }
        }

        // Discrete
        else if (color.invertExtent) {
            const thresholds = color.thresholds ? color.thresholds() // scaleQuantize
                :
                color.quantiles ? color.quantiles() // scaleQuantile
                :
                color.domain(); // scaleThreshold

            const thresholdFormat = tickFormat === undefined ? d => d :
                typeof tickFormat === "string" ? d3.format(tickFormat) :
                tickFormat;

            x = d3.scaleLinear()
                .domain([-1, color.range().length - 1])
                .rangeRound([marginLeft, width - marginRight]);

            svg.append("g")
                .selectAll("rect")
                .data(color.range())
                .join("rect")
                .attr("x", (d, i) => x(i - 1))
                .attr("y", marginTop)
                .attr("width", (d, i) => x(i) - x(i - 1))
                .attr("height", height - marginTop - marginBottom)
                .attr("fill", d => d);

            tickValues = d3.range(thresholds.length);
            tickFormat = i => thresholdFormat(thresholds[i], i);
        }

        svg.append("g")
            .attr("transform", `translate(0, ${height - marginBottom})`)
            .call(d3.axisBottom(x)
                .ticks(ticks, typeof tickFormat === "string" ? tickFormat : undefined)
                .tickFormat(typeof tickFormat === "function" ? tickFormat : undefined)
                .tickSize(tickSize)
                .tickValues(tickValues))
            .call(g => g.selectAll(".tick line").attr("y1", marginTop + marginBottom - height))
            .call(g => g.select(".domain").remove())
            .call(g => g.append("text")
                .attr("y", marginTop + marginBottom - height - 6)
                .attr("fill", "currentColor")
                .attr("text-anchor", "start")
                .attr("font-weight", "bold")
                .text(title));

        return svg.node();
    }
</script>

</html>